diff --git a/ocgapi.cpp b/ocgapi.cpp
index fe6a7e9..1d466c2 100644
--- a/ocgapi.cpp
+++ b/ocgapi.cpp
@@ -281,3 +281,47 @@ OCGAPI void* OCG_DuelQueryField(OCG_Duel ocg_duel, uint32_t* length) {
 		*length = static_cast<uint32_t>(query.size());
 	return query.data();
 }
+
+// modified from query_card()
+OCGAPI uint32_t query_linked_zone(OCG_Duel pduel, uint8_t playerid, uint8_t location, uint8_t sequence) {
+	if(playerid != 0 && playerid != 1)
+		return 0;
+	duel* ptduel = (duel*)pduel;
+	card* pcard = 0;
+	location &= 0x7f;
+	if(location & LOCATION_ONFIELD)
+		pcard = ptduel->game_field->get_field_card(playerid, location, sequence);
+	else {
+		card_vector* lst = 0;
+		if(location == LOCATION_HAND )
+			lst = &ptduel->game_field->player[playerid].list_hand;
+		else if(location == LOCATION_GRAVE )
+			lst = &ptduel->game_field->player[playerid].list_grave;
+		else if(location == LOCATION_REMOVED )
+			lst = &ptduel->game_field->player[playerid].list_remove;
+		else if(location == LOCATION_EXTRA )
+			lst = &ptduel->game_field->player[playerid].list_extra;
+		else if(location == LOCATION_DECK )
+			lst = &ptduel->game_field->player[playerid].list_main;
+		if(!lst || sequence > lst->size())
+			pcard = 0;
+		else {
+			auto cit = lst->begin();
+			for(uint32_t i = 0; i < sequence; ++i, ++cit);
+			pcard = *cit;
+		}
+	}
+	if(pcard)
+		return pcard->get_linked_zone();
+	else {
+		return 0;
+	}
+}	
+int32_t is_declarable(const card_data& cd, const std::vector<uint64_t>& opcodes);
+OCGAPI int32_t declarable(card_data *cd, int32_t size, uint32_t *array) {
+	std::vector<uint64_t> v;
+	for (int i=0; i < size; i++) {
+	v.push_back(array[i]);
+	}
+	return is_declarable(*cd, v);
+}
diff --git a/playerop.cpp b/playerop.cpp
index 125369b..23531cb 100644
--- a/playerop.cpp
+++ b/playerop.cpp
@@ -997,7 +997,7 @@ bool field::process(Processors::AnnounceAttribute& arg) {
 								stack.push(cd.val);\
 								break;\
 							}
-static int32_t is_declarable(const card_data& cd, const std::vector<uint64_t>& opcodes) {
+int32_t is_declarable(const card_data& cd, const std::vector<uint64_t>& opcodes) {
 	std::stack<int64_t> stack;
 	bool alias = false, token = false;
 	for(auto& opcode : opcodes) {
